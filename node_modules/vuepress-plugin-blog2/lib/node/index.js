import{createPage as T,preparePageComponent as O,preparePageData as V,preparePagesComponents as j,preparePagesData as K,preparePagesRoutes as A}from"@vuepress/core";import{Logger as F,getPageExcerpt as G}from"vuepress-shared/node";import{watch as J}from"chokidar";import{isString as C,isFunction as L,removeLeadingSlash as D}from"@vuepress/shared";import{colors as _}from"@vuepress/utils";const r=new F("vuepress-plugin-blog2"),H=(t,b)=>{const m={};return Object.keys({"/":{},...b.options.locales}).forEach(g=>{m[g]=[]}),b.pages.filter(t).forEach(g=>{m[g.pathLocale].push(g)}),m},z=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,S=(t,b,m,g=!1)=>{const{category:E=[],slugify:M=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=b;return Promise.all(E.map(async({key:a,getter:f,sorter:k=()=>-1,path:i="/:key/",layout:y="Layout",frontmatter:e=()=>({}),itemPath:v="/:key/:name/",itemLayout:c="Layout",itemFrontmatter:w=()=>({})},p)=>{if(!C(a)||!a)return r.error(`Invalid ${_.magenta("key")} option ${_.cyan(a)} in ${_.cyan(`category[${p}]`)}`),null;if(!L(f))return r.error(`Invalid ${_.magenta("getter")} option in "${_.cyan(`category[${p}]`)}", it should be a function!`),null;t.env.isDebug&&r.info(`Generating ${_.cyan(a)} category.
`);const h={},o=[],u=L(v)?v:n=>(v||"").replace(/:key/g,M(a)).replace(/:name/g,M(n));for(const n in m){if(i){const d=`${n}${D(i.replace(/:key/g,M(a)))}`,$=await T(t,{path:d,frontmatter:{...e(n),blog:{type:"category",key:a},layout:y}}),s=t.pages.findIndex(({path:P})=>P===d);s===-1?t.pages.push($):t.pages[s].key!==$.key&&(t.pages.splice(s,1,$),g&&r.warn(`Overriding existed path ${_.cyan(d)}`)),o.push($.key),h[n]={path:$.path,map:{}}}else h[n]={path:"",map:{}};const{map:l}=h[n],x={};for(const d of m[n]){const $=f(d);for(const s of $){if(!l[s]){const P=u(s);if(P){const U=`${n}${D(P)}`,R=await T(t,{path:`${n}${D(P)}`,frontmatter:{...w(s,n),blog:{type:"category",name:s,key:a},layout:c}}),I=t.pages.findIndex(({path:N})=>N===U);I===-1?t.pages.push(R):t.pages[I].key!==R.key&&(t.pages.splice(I,1,R),g&&r.warn(`Overriding existed path ${U}`)),o.push(R.key),l[s]={path:R.path,keys:[]}}else l[s]={path:"",keys:[]};x[s]=[]}x[s].push(d)}}for(const d in x)l[d].keys=x[d].sort(k).map(({key:$})=>$);if(t.env.isDebug){let d=`Route ${n} in ${a} category:
`;for(const $ in l){const{path:s,keys:P}=l[$];d+=`name: ${$}; ${s?`path: ${s}; `:""}items: ${P.length}
`}r.info(d)}}return{key:a,map:h,pageKeys:o}})).then(async a=>{const f={},k=[];return a.filter(i=>i!==null).forEach(({key:i,map:y,pageKeys:e})=>{f[i]=y,k.push(...e)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(f)};
${t.env.isDev?z:""}
`),t.env.isDebug&&r.info("All categories generated."),k})},W=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,B=(t,b,m,g=!1)=>{const{type:E=[],slugify:M=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=b;return Promise.all(E.map(async({key:a,sorter:f=()=>-1,filter:k=()=>!0,path:i="/:key/",layout:y="Layout",frontmatter:e=()=>({})},v)=>{if(!C(a)||!a)return r.error(`Invalid ${_.magenta("key")} option ${_.cyan(a)} in ${_.cyan(`type[${v}]`)}`),null;const c={},w=[];t.env.isDebug&&r.info(`Generating ${_.cyan(a)} type.
`);for(const p in m){const h=m[p].filter(k).sort(f).map(({key:o})=>o);if(i){const o=`${p}${D(M(i.replace(/:key/g,a)))}`,u=await T(t,{path:o,frontmatter:{...e(p),blog:{type:"type",key:a},layout:y}}),n=t.pages.findIndex(({path:l})=>l===o);n===-1?t.pages.push(u):t.pages[n].key!==u.key&&(t.pages.splice(n,1,u),g&&r.warn(`Overriding existed path ${_.cyan(o)}`)),w.push(u.key),c[p]={path:u.path,keys:h},t.env.isDebug&&r.info(`Route ${p} in ${a} type: path: ${u.path}; items: ${h.length}
`)}else c[p]={path:"",keys:h},t.env.isDebug&&r.info(`Route ${p} in ${a} type: items: ${h.length}
`)}return{key:a,map:c,pageKeys:w}})).then(async a=>{const f={},k=[];return a.filter(i=>i!==null).forEach(({key:i,map:y,pageKeys:e})=>{f[i]=y,k.push(...e)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(f)};
${t.env.isDev?W:""}
`),t.env.isDebug&&r.info("All types generated."),k})},q=t=>b=>{const{getInfo:m=()=>({}),filter:g=e=>Boolean(e.filePathRelative)&&!e.frontmatter.home,metaScope:E="_blog",excerpt:M=!0,excerptSeparator:a="<!-- more -->",excerptLength:f=300,excerptFilter:k=g,isCustomElement:i=()=>!1}=t;let y=[];return b.env.isDebug&&r.info("Options:",t),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:E}),extendsPage:e=>{M&&k(e)&&(e.data.excerpt=G(b,e,{isCustomElement:i,excerptSeparator:a,excerptLength:f})),g(e)&&(e.routeMeta={...E===""?m(e):{[E]:m(e)},...e.routeMeta})},onInitialized:e=>{const v=H(g,e);return Promise.all([S(e,t,v,!0).then(c=>{y.push(...c)}),B(e,t,v,!0).then(c=>{y.push(...c)})]).then(()=>{e.env.isDebug&&r.info("temp file generated")})},onWatched:(e,v)=>{if("hotReload"in t?t.hotReload:e.env.isDebug){const c=J("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),w=()=>{const p=[],h=H(g,e);return Promise.all([S(e,t,h).then(o=>{p.push(...o)}),B(e,t,h).then(o=>{p.push(...o)})]).then(async()=>{const o=y.filter(n=>!p.includes(n)),u=p.filter(n=>!y.includes(n));u.length&&(e.env.isDebug&&r.info(`New pages detected: ${u.toString()}`),await Promise.all(u.map(async n=>{await O(e,e.pages.find(({key:l})=>l===n)),await V(e,e.pages.find(({key:l})=>l===n))}))),o.length&&(e.env.isDebug&&r.info(`Removing following pages: ${o.toString()}`),o.forEach(n=>{e.pages.splice(e.pages.findIndex(({key:l})=>l===n),1)})),(o.length||u.length)&&(await j(e),await K(e),await A(e)),y=p,e.env.isDebug&&r.info("temp file updated")})};c.on("add",()=>{w()}),c.on("change",()=>{w()}),c.on("unlink",()=>{w()}),v.push(c)}}}};export{q as blogPlugin};
//# sourceMappingURL=index.js.map
