const e=JSON.parse('{"key":"v-4652ce5a","path":"/other/mq/2.html","title":"MQ","lang":"zh-CN","frontmatter":{"title":"MQ","icon":"page","order":61,"author":"xss","date":"2023-12-11T00:00:00.000Z","category":["MQ"],"tag":["MQ"],"footer":"这是测试显示的页脚","copyright":"无版权","description":"public class demo { public static void main(String[] args) throws IOException, TimeoutException { publish1(); publish2(); //consume(); } private static void publish1() throws IOException, TimeoutException { //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"192.168.80.131\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明队列。 //参数1：队列名 //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在） //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除） //参数4：当所有消费者客户端连接断开时是否自动删除队列 //参数5：队列的其他参数 channel.queueDeclare(\\"msg\\", true, false, false, null); //发布消息 String message = \\"hello\\"; // 基本发布消息 // 第一个参数为交换机名称(空) // 第二个参数为队列映射的路由key(直接使用队列名) // 第三个参数为消息的其他属性、 // 第四个参数为发送信息的主体 channel.basicPublish(\\"\\", \\"msg\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8)); channel.close(); conn.close(); } private static void publish2() throws IOException, TimeoutException { //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"localhost\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明交换器 String exchangeName = \\"/chat\\"; channel.exchangeDeclare(exchangeName, \\"direct\\", true); //声明队列。 //参数1：队列名 //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在） //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除） //参数4：当所有消费者客户端连接断开时是否自动删除队列 //参数5：队列的其他参数 channel.queueDeclare(\\"msg\\", true, false, false, null); //队列绑定到交换机 String routingKey = \\"tag1\\"; channel.queueBind(\\"msg\\", \\"/chat\\", routingKey); //发布消息 String message = \\"hello\\"; // 基本发布消息 // 第一个参数为交换机名称、 // 第二个参数为队列映射的路由key、 // 第三个参数为消息的其他属性 指定持久化 (创建队列也需要配置持久化) // 第四个参数为发送信息的主体 channel.basicPublish(\\"/chat\\", \\"tag1\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8)); channel.close(); conn.close(); } private static void consume() throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"localhost\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明队列 channel.queueDeclare(\\"msg\\", true, false, false, null); while (true) { //消费消息 boolean autoAck = false; String consumerTag = \\"\\"; channel.basicConsume(\\"msg\\", autoAck, consumerTag, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String routingKey = envelope.getRoutingKey(); String contentType = properties.getContentType(); System.out.println(\\"消费的路由键：\\" + routingKey); System.out.println(\\"消费的内容类型：\\" + contentType); System.out.println(\\"消费的消息体内容：\\"); String bodyStr = new String(body, \\"UTF-8\\"); System.out.println(bodyStr); sleep(1000); //确认消息 long deliveryTag = envelope.getDeliveryTag(); channel.basicAck(deliveryTag, false); } }); } } private static void sleep(long t) { try { Thread.sleep(t); } catch (InterruptedException e) { e.printStackTrace(); } }","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/other/mq/2.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"MQ"}],["meta",{"property":"og:description","content":"public class demo { public static void main(String[] args) throws IOException, TimeoutException { publish1(); publish2(); //consume(); } private static void publish1() throws IOException, TimeoutException { //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"192.168.80.131\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明队列。 //参数1：队列名 //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在） //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除） //参数4：当所有消费者客户端连接断开时是否自动删除队列 //参数5：队列的其他参数 channel.queueDeclare(\\"msg\\", true, false, false, null); //发布消息 String message = \\"hello\\"; // 基本发布消息 // 第一个参数为交换机名称(空) // 第二个参数为队列映射的路由key(直接使用队列名) // 第三个参数为消息的其他属性、 // 第四个参数为发送信息的主体 channel.basicPublish(\\"\\", \\"msg\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8)); channel.close(); conn.close(); } private static void publish2() throws IOException, TimeoutException { //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"localhost\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明交换器 String exchangeName = \\"/chat\\"; channel.exchangeDeclare(exchangeName, \\"direct\\", true); //声明队列。 //参数1：队列名 //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在） //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除） //参数4：当所有消费者客户端连接断开时是否自动删除队列 //参数5：队列的其他参数 channel.queueDeclare(\\"msg\\", true, false, false, null); //队列绑定到交换机 String routingKey = \\"tag1\\"; channel.queueBind(\\"msg\\", \\"/chat\\", routingKey); //发布消息 String message = \\"hello\\"; // 基本发布消息 // 第一个参数为交换机名称、 // 第二个参数为队列映射的路由key、 // 第三个参数为消息的其他属性 指定持久化 (创建队列也需要配置持久化) // 第四个参数为发送信息的主体 channel.basicPublish(\\"/chat\\", \\"tag1\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8)); channel.close(); conn.close(); } private static void consume() throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\\"admin\\"); factory.setPassword(\\"admin123\\"); //设置 RabbitMQ 地址 factory.setHost(\\"localhost\\"); factory.setPort(5672); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明队列 channel.queueDeclare(\\"msg\\", true, false, false, null); while (true) { //消费消息 boolean autoAck = false; String consumerTag = \\"\\"; channel.basicConsume(\\"msg\\", autoAck, consumerTag, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String routingKey = envelope.getRoutingKey(); String contentType = properties.getContentType(); System.out.println(\\"消费的路由键：\\" + routingKey); System.out.println(\\"消费的内容类型：\\" + contentType); System.out.println(\\"消费的消息体内容：\\"); String bodyStr = new String(body, \\"UTF-8\\"); System.out.println(bodyStr); sleep(1000); //确认消息 long deliveryTag = envelope.getDeliveryTag(); channel.basicAck(deliveryTag, false); } }); } } private static void sleep(long t) { try { Thread.sleep(t); } catch (InterruptedException e) { e.printStackTrace(); } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"xss"}],["meta",{"property":"article:tag","content":"MQ"}],["meta",{"property":"article:published_time","content":"2023-12-11T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MQ\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xss\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.6,"words":780},"filePathRelative":"other/mq/2.md","localizedDate":"2023年12月11日","excerpt":"<p>public class demo {\\npublic static void main(String[] args) throws IOException, TimeoutException {</p>\\n<pre><code>    publish1();\\n    publish2();\\n\\n    //consume();\\n}\\n\\n\\nprivate static void publish1() throws IOException, TimeoutException {\\n    //创建连接工厂\\n    ConnectionFactory factory = new ConnectionFactory();\\n\\n    factory.setUsername(\\"admin\\");\\n    factory.setPassword(\\"admin123\\");\\n\\n    //设置 RabbitMQ 地址\\n    factory.setHost(\\"192.168.80.131\\");\\n    factory.setPort(5672);\\n\\n    //建立到代理服务器到连接\\n    Connection conn = factory.newConnection();\\n\\n    //获得信道\\n    Channel channel = conn.createChannel();\\n\\n    //声明队列。\\n    //参数1：队列名\\n    //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在）\\n    //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除）\\n    //参数4：当所有消费者客户端连接断开时是否自动删除队列\\n    //参数5：队列的其他参数\\n    channel.queueDeclare(\\"msg\\", true, false, false, null);\\n\\n    //发布消息\\n    String message = \\"hello\\";\\n\\n    // 基本发布消息\\n    // 第一个参数为交换机名称(空)\\n    // 第二个参数为队列映射的路由key(直接使用队列名)\\n    // 第三个参数为消息的其他属性、\\n    // 第四个参数为发送信息的主体\\n    channel.basicPublish(\\"\\", \\"msg\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8));\\n\\n    channel.close();\\n    conn.close();\\n}\\n\\nprivate static void publish2() throws IOException, TimeoutException {\\n    //创建连接工厂\\n    ConnectionFactory factory = new ConnectionFactory();\\n\\n    factory.setUsername(\\"admin\\");\\n    factory.setPassword(\\"admin123\\");\\n\\n    //设置 RabbitMQ 地址\\n    factory.setHost(\\"localhost\\");\\n    factory.setPort(5672);\\n\\n    //建立到代理服务器到连接\\n    Connection conn = factory.newConnection();\\n\\n    //获得信道\\n    Channel channel = conn.createChannel();\\n\\n    //声明交换器\\n    String exchangeName = \\"/chat\\";\\n    channel.exchangeDeclare(exchangeName, \\"direct\\", true);\\n\\n\\n    //声明队列。\\n    //参数1：队列名\\n    //参数2：持久化 （true表示是，队列将在服务器重启时依旧存在）\\n    //参数3：独占队列（创建者可以使用的私有队列，断开后自动删除）\\n    //参数4：当所有消费者客户端连接断开时是否自动删除队列\\n    //参数5：队列的其他参数\\n    channel.queueDeclare(\\"msg\\", true, false, false, null);\\n\\n    //队列绑定到交换机\\n    String routingKey = \\"tag1\\";\\n    channel.queueBind(\\"msg\\", \\"/chat\\", routingKey);\\n\\n\\n    //发布消息\\n    String message = \\"hello\\";\\n\\n\\n    // 基本发布消息\\n    // 第一个参数为交换机名称、\\n    // 第二个参数为队列映射的路由key、\\n    // 第三个参数为消息的其他属性 指定持久化 (创建队列也需要配置持久化)\\n    // 第四个参数为发送信息的主体\\n    channel.basicPublish(\\"/chat\\", \\"tag1\\", MessageProperties.MINIMAL_PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8));\\n\\n\\n    channel.close();\\n    conn.close();\\n}\\n\\nprivate static void consume() throws IOException, TimeoutException {\\n    ConnectionFactory factory = new ConnectionFactory();\\n    factory.setUsername(\\"admin\\");\\n    factory.setPassword(\\"admin123\\");\\n\\n    //设置 RabbitMQ 地址\\n    factory.setHost(\\"localhost\\");\\n    factory.setPort(5672);\\n\\n    //建立到代理服务器到连接\\n    Connection conn = factory.newConnection();\\n\\n    //获得信道\\n    Channel channel = conn.createChannel();\\n\\n    //声明队列\\n    channel.queueDeclare(\\"msg\\", true, false, false, null);\\n\\n    while (true) {\\n        //消费消息\\n        boolean autoAck = false;\\n        String consumerTag = \\"\\";\\n        channel.basicConsume(\\"msg\\", autoAck, consumerTag, new DefaultConsumer(channel) {\\n            @Override\\n            public void handleDelivery(String consumerTag,\\n                                       Envelope envelope,\\n                                       AMQP.BasicProperties properties,\\n                                       byte[] body) throws IOException {\\n\\n                String routingKey = envelope.getRoutingKey();\\n                String contentType = properties.getContentType();\\n\\n                System.out.println(\\"消费的路由键：\\" + routingKey);\\n                System.out.println(\\"消费的内容类型：\\" + contentType);\\n\\n                System.out.println(\\"消费的消息体内容：\\");\\n                String bodyStr = new String(body, \\"UTF-8\\");\\n                System.out.println(bodyStr);\\n\\n                sleep(1000);\\n\\n                //确认消息\\n                long deliveryTag = envelope.getDeliveryTag();\\n                channel.basicAck(deliveryTag, false);\\n\\n            }\\n        });\\n    }\\n}\\n\\nprivate static void sleep(long t) {\\n    try {\\n        Thread.sleep(t);\\n    } catch (InterruptedException e) {\\n        e.printStackTrace();\\n    }\\n}\\n</code></pre>","autoDesc":true}');export{e as data};
